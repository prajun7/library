"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const traverse_1 = __importDefault(require("@babel/traverse"));
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
        enableScope: false,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        allowTemplateLiteral: false,
        enableScope: true,
    },
];
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        return {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = Object.assign({ targetFormat: 'wire', outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(t, path);
                        state.program = path;
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let options = referencesInlineCompiler(tagPath, state);
                    if (!options) {
                        return;
                    }
                    if (!options.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, template, path, {});
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, options);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let options = referencesInlineCompiler(calleePath, state);
                    if (!options) {
                        return;
                    }
                    let [firstArg, secondArg, ...restArgs] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, options.enableScope);
                    }
                    if (restArgs.length > 0) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, template, path, userTypedOptions);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, options);
                    }
                },
            },
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions) {
    if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals();
    }
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope, state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            ast: state.normalizedOpts.transforms,
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    return output;
}
// if scope has different keys and values, this function will remap the keys to the values
// you can see an example of this in the test "correctly handles scope if it contains keys and values"
function remapIdentifiers(ast, babel, scopeLocals) {
    if (!scopeLocals.needsRemapping()) {
        // do nothing if all keys are the same as their values
        return;
    }
    (0, traverse_1.default)(ast, {
        Identifier(path) {
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // replace the path only if the key is different from the value
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
        },
    });
}
function insertCompiledTemplate(babel, state, template, target, userTypedOptions) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, scopeLocals);
    let precompileResultString;
    if (options.insertRuntimeErrors) {
        try {
            precompileResultString = state.normalizedOpts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = state.normalizedOpts.compiler.precompile(template, options);
    }
    let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString}; `, {
        babelrc: false,
        configFile: false,
    });
    remapIdentifiers(precompileResultAST, babel, scopeLocals);
    let templateExpression = precompileResultAST.program.body[0]
        .declarations[0].init;
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    let templateFactoryIdentifier = state.util.import(target, state.templateFactory.moduleName, state.templateFactory.exportName);
    target.replaceWith(t.callExpression(templateFactoryIdentifier, [templateExpression]));
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, scopeLocals);
    let ast = state.normalizedOpts.compiler._preprocess(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = state.normalizedOpts.compiler._print(ast);
    if (target.isCallExpression()) {
        target.get('arguments.0').replaceWith(t.stringLiteral(transformed));
        if (!scopeLocals.isEmpty()) {
            if (!formatOptions.enableScope) {
                maybePruneImport(state.util, target.get('callee'));
                target.set('callee', precompileTemplate(state.util, target));
            }
            updateScope(babel, target, scopeLocals);
        }
    }
    else {
        if (!scopeLocals.isEmpty()) {
            // need to add scope, so need to replace the backticks form with a call
            // expression to precompileTemplate
            maybePruneImport(state.util, target.get('tag'));
            let newCall = target.replaceWith(t.callExpression(precompileTemplate(state.util, target), [t.stringLiteral(transformed)]))[0];
            updateScope(babel, newCall, scopeLocals);
        }
        else {
            target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        }
    }
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            scope.set('value', buildScope(babel, locals));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    // this checks if the identifier (that we're about to remove) is used in
    // exactly one place.
    if ((binding === null || binding === void 0 ? void 0 : binding.referencePaths.reduce((count, path) => (path.removed ? count : count + 1), 0)) === 1) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
    identifier.removed = true;
}
function precompileTemplate(util, target) {
    return util.import(target, '@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsK0RBQXVDO0FBR3ZDLHlEQUErQztBQUMvQywyREFBdUQ7QUFDdkQseUNBQTREO0FBRzVELGlEQUE2QztBQUU3QyxpREFBK0I7QUFXL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtRQUMxQixXQUFXLEVBQUUsS0FBSztLQUNuQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO1FBQzFCLFdBQVcsRUFBRSxLQUFLO0tBQ25CO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7UUFDMUIsV0FBVyxFQUFFLEtBQUs7S0FDbkI7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixvQkFBb0IsRUFBRSxLQUFLO1FBQzNCLFdBQVcsRUFBRSxJQUFJO0tBQ2xCO0NBQ0YsQ0FBQztBQXVERixTQUFnQixVQUFVLENBQXFCLFdBQWtEO0lBQy9GLE9BQU8sU0FBUyx3QkFBd0IsQ0FDdEMsS0FBbUI7UUFFbkIsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUVwQixPQUFPO1lBQ0wsT0FBTyxFQUFFO2dCQUNQLE9BQU8sRUFBRTtvQkFDUCxLQUFLLENBQUMsSUFBeUIsRUFBRSxLQUFnQzt3QkFDL0QsS0FBSyxDQUFDLGNBQWMsbUJBQ2xCLFlBQVksRUFBRSxNQUFNLEVBQ3BCLHFCQUFxQixFQUFFLEVBQUUsRUFDekIsbUJBQW1CLEVBQUUsRUFBRSxFQUN2QixVQUFV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Q0UsQ0FBQSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQUssQ0FBQyxFQUM1RjtRQUNBLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxTQUFTLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUNqQyxJQUFJLFdBQVcsR0FBRyxTQUFTLENBQUMsVUFBMkMsQ0FBQztZQUN4RSxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQ2pGO0tBQ0Y7SUFDRCxVQUFVLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUM1QixDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxJQUFnQixFQUFFLE1BQXdCO0lBQ3BFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsNkJBQTZCLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBRUQsU0FBUyxJQUFJLENBQUMsSUFBb0M7SUFDaEQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBRTtRQUNqQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxrQkFBZSxVQUFVLENBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC90cmF2ZXJzZSc7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgSW1wb3J0VXRpbCB9IGZyb20gJ2JhYmVsLWltcG9ydC11dGlsJztcbmltcG9ydCB7IEV4cHJlc3Npb25QYXJzZXIgfSBmcm9tICcuL2V4cHJlc3Npb24tcGFyc2VyJztcbmltcG9ydCB7IEpTVXRpbHMsIEV4dGVuZGVkUGx1Z2luQnVpbGRlciB9IGZyb20gJy4vanMtdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBFbWJlclRlbXBsYXRlQ29tcGlsZXIsIFByZXByb2Nlc3NPcHRpb25zIH0gZnJvbSAnLi9lbWJlci10ZW1wbGF0ZS1jb21waWxlcic7XG5pbXBvcnQgeyBMZWdhY3lNb2R1bGVOYW1lIH0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vcHVibGljLXR5cGVzJztcblxudHlwZSBNb2R1bGVOYW1lID0gTGVnYWN5TW9kdWxlTmFtZSB8ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nO1xuXG5pbnRlcmZhY2UgTW9kdWxlQ29uZmlnIHtcbiAgbW9kdWxlTmFtZTogTW9kdWxlTmFtZTtcbiAgZXhwb3J0OiBzdHJpbmc7XG4gIGFsbG93VGVtcGxhdGVMaXRlcmFsOiBib29sZWFuO1xuICBlbmFibGVTY29wZTogYm9vbGVhbjtcbn1cblxuY29uc3QgSU5MSU5FX1BSRUNPTVBJTEVfTU9EVUxFUzogTW9kdWxlQ29uZmlnW10gPSBbXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzJyxcbiAgICBleHBvcnQ6ICdoYnMnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICAgIGVuYWJsZVNjb3BlOiBmYWxzZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdlbWJlci1jbGktaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICAgIGVuYWJsZVNjb3BlOiBmYWxzZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdodG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZScsXG4gICAgZXhwb3J0OiAnZGVmYXVsdCcsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gICAgZW5hYmxlU2NvcGU6IGZhbHNlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicsXG4gICAgZXhwb3J0OiAncHJlY29tcGlsZVRlbXBsYXRlJyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogZmFsc2UsXG4gICAgZW5hYmxlU2NvcGU6IHRydWUsXG4gIH0sXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAvLyBUaGUgZW1iZXItdGVtcGxhdGUtY29tcGlsZXIuanMgbW9kdWxlIHRoYXQgc2hpcHMgd2l0aGluIHlvdXIgZW1iZXItc291cmNlIHZlcnNpb24uXG4gIGNvbXBpbGVyOiBFbWJlclRlbXBsYXRlQ29tcGlsZXI7XG5cbiAgLy8gQWxsb3dzIHlvdSB0byByZW1hcCB3aGF0IGltcG9ydHMgd2lsbCBiZSBlbWl0dGVkIGluIG91ciBjb21waWxlZCBvdXRwdXQuIEJ5XG4gIC8vIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7XG4gIC8vICAgICAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknOiB7XG4gIC8vICAgICAgIGNyZWF0ZVRlbXBsYXRlRmFjdG9yeTogWydjcmVhdGVUZW1wbGF0ZUZhY3RvcnknLCAnQGdsaW1tZXIvY29yZSddLFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gTm9ybWFsIEVtYmVyIGFwcHMgc2hvdWxkbid0IG5lZWQgdGhpcywgaXQgZXhpc3RzIHRvIHN1cHBvcnQgb3RoZXJcbiAgLy8gZW52aXJvbm1lbnRzIGxpa2Ugc3RhbmRhbG9uZSBHbGltbWVySlNcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIHRoaXMgcGx1Z2luIGltcGxlbWVudHMgb25seSBFbWJlcidzIHN0YWJsZSBwdWJsaWMgQVBJIGZvclxuICAvLyB0ZW1wbGF0ZSBjb21waWxhdGlvbiwgd2hpY2ggaXM6XG4gIC8vXG4gIC8vICAgIGltcG9ydCB7IHByZWNvbXBpbGVUZW1wbGF0ZSB9IGZyb20gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbic7XG4gIC8vXG4gIC8vIEJ1dCBoaXN0b3JpY2FsbHkgdGhlcmUgYXJlIHNldmVyYWwgb3RoZXIgaW1wb3J0YWJsZSBzeW50YXhlcyBpbiB3aWRlc3ByZWFkXG4gIC8vIHVzZSwgYW5kIHdlIGNhbiBlbmFibGUgdGhvc2UgdG9vIGJ5IGluY2x1ZGluZyB0aGVpciBtb2R1bGUgbmFtZXMgaW4gdGhpc1xuICAvLyBsaXN0LlxuICBlbmFibGVMZWdhY3lNb2R1bGVzPzogTGVnYWN5TW9kdWxlTmFtZVtdO1xuXG4gIC8vIENvbnRyb2xzIHRoZSBvdXRwdXQgZm9ybWF0LlxuICAvL1xuICAvLyAgXCJ3aXJlXCI6IFRoZSBkZWZhdWx0LiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyBhcmUgcmVhZHkgdG8gZXhlY3V0ZSBpblxuICAvLyAgdGhlIG1vc3QgcGVyZm9ybWFudCB3YXkuXG4gIC8vXG4gIC8vICBcImhic1wiOiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyB3aWxsIHN0aWxsIGJlIGluIEhCUyBmb3JtYXQuXG4gIC8vICBHZW5lcmFsbHkgdGhpcyBtZWFucyB0aGV5IHdpbGwgc3RpbGwgbmVlZCBmdXJ0aGVyIHByb2Nlc3NpbmcgYmVmb3JlXG4gIC8vICB0aGV5J3JlIHJlYWR5IHRvIGV4ZWN1dGUuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbW9kZSBpcyB0byBzdXBwb3J0IHRoaW5nc1xuICAvLyAgbGlrZSBjb2RlbW9kcyBhbmQgcHJlLXB1YmxpY2F0aW9uIHRyYW5zZm9ybWF0aW9ucyBpbiBsaWJyYXJpZXMuXG4gIHRhcmdldEZvcm1hdD86ICd3aXJlJyB8ICdoYnMnO1xuXG4gIC8vIE9wdGlvbmFsIGxpc3Qgb2YgY3VzdG9tIHRyYW5zZm9ybXMgdG8gYXBwbHkgdG8gdGhlIGhhbmRsZWJhcnMgQVNUIGJlZm9yZVxuICAvLyBjb21waWxhdGlvbi5cbiAgdHJhbnNmb3Jtcz86IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG5pbnRlcmZhY2UgU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPiB7XG4gIG9wdHM6IEVudlNwZWNpZmljT3B0aW9ucztcbiAgbm9ybWFsaXplZE9wdHM6IFJlcXVpcmVkPE9wdGlvbnM+O1xuICB1dGlsOiBJbXBvcnRVdGlsO1xuICB0ZW1wbGF0ZUZhY3Rvcnk6IHsgbW9kdWxlTmFtZTogc3RyaW5nOyBleHBvcnROYW1lOiBzdHJpbmcgfTtcbiAgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPjtcbiAgbGFzdEluc2VydGVkUGF0aDogTm9kZVBhdGg8dC5TdGF0ZW1lbnQ+IHwgdW5kZWZpbmVkO1xuICBmaWxlbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBsdWdpbjxFbnZTcGVjaWZpY09wdGlvbnM+KGxvYWRPcHRpb25zOiAob3B0czogRW52U3BlY2lmaWNPcHRpb25zKSA9PiBPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBodG1sYmFyc0lubGluZVByZWNvbXBpbGUoXG4gICAgYmFiZWw6IHR5cGVvZiBCYWJlbFxuICApOiBCYWJlbC5QbHVnaW5PYmo8U3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPj4ge1xuICAgIGxldCB0ID0gYmFiZWwudHlwZXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaXRvcjoge1xuICAgICAgICBQcm9ncmFtOiB7XG4gICAgICAgICAgZW50ZXIocGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzID0ge1xuICAgICAgICAgICAgICB0YXJnZXRGb3JtYXQ6ICd3aXJlJyxcbiAgICAgICAgICAgICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7fSxcbiAgICAgICAgICAgICAgZW5hYmxlTGVnYWN5TW9kdWxlczogW10sXG4gICAgICAgICAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgICAgICAgICAuLi5sb2FkT3B0aW9ucyhzdGF0ZS5vcHRzKSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeSA9IHRlbXBsYXRlRmFjdG9yeUNvbmZpZyhzdGF0ZS5ub3JtYWxpemVkT3B0cyk7XG4gICAgICAgICAgICBzdGF0ZS51dGlsID0gbmV3IEltcG9ydFV0aWwodCwgcGF0aCk7XG4gICAgICAgICAgICBzdGF0ZS5wcm9ncmFtID0gcGF0aDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4aXQoX3BhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeyBtb2R1bGVOYW1lLCBleHBvcnQ6IGV4cG9ydE5hbWUgfSBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGlsLnJlbW92ZUltcG9ydChtb2R1bGVOYW1lLCBleHBvcnROYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKFxuICAgICAgICAgIHBhdGg6IE5vZGVQYXRoPHQuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uPixcbiAgICAgICAgICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgdGFnUGF0aCA9IHBhdGguZ2V0KCd0YWcnKTtcblxuICAgICAgICAgIGlmICghdGFnUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgb3B0aW9ucyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcih0YWdQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93VGVtcGxhdGVMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIFxcYCR7dGFnUGF0aC5ub2RlLm5hbWV9XFxgIGFzIGEgdGVtcGxhdGUgdGFnLCBidXQgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBwYXNzZWQgdG8gaXQ6ICR7dGFnUGF0aC5ub2RlLm5hbWV9KCdjb250ZW50IGhlcmUnKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGgubm9kZS5xdWFzaS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0YWdnZWQgdGVtcGxhdGUgc3RyaW5nIGFyZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBwYXRoLm5vZGUucXVhc2kucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKGJhYmVsLCBzdGF0ZSwgdGVtcGxhdGUsIHBhdGgsIHt9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0VHJhbnNmb3JtZWRUZW1wbGF0ZShiYWJlbCwgc3RhdGUsIHRlbXBsYXRlLCBwYXRoLCB7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxFeHByZXNzaW9uKHBhdGg6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgIGxldCBjYWxsZWVQYXRoID0gcGF0aC5nZXQoJ2NhbGxlZScpO1xuXG4gICAgICAgICAgaWYgKCFjYWxsZWVQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBvcHRpb25zID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKGNhbGxlZVBhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgW2ZpcnN0QXJnLCBzZWNvbmRBcmcsIC4uLnJlc3RBcmdzXSA9IHBhdGguZ2V0KCdhcmd1bWVudHMnKTtcblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmlyc3RBcmc/Lm5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUZW1wbGF0ZUxpdGVyYWwnOlxuICAgICAgICAgICAgICBpZiAoZmlyc3RBcmcubm9kZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRlbXBsYXRlIHN0cmluZyBhcmUgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZ3MgaW5zaWRlICR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGFyZSBub3Qgc3VwcG9ydGVkYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBzaG91bGQgYmUgaW52b2tlZCB3aXRoIGF0IGxlYXN0IGEgc2luZ2xlIGFyZ3VtZW50ICh0aGUgdGVtcGxhdGUgc3RyaW5nKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbiAgICAgICAgICBpZiAoIXNlY29uZEFyZykge1xuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlY29uZEFyZy5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGNhbiBvbmx5IGJlIGludm9rZWQgd2l0aCAyIGFyZ3VtZW50czogdGhlIHRlbXBsYXRlIHN0cmluZywgYW5kIGFueSBzdGF0aWMgb3B0aW9uc2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IG5ldyBFeHByZXNzaW9uUGFyc2VyKGJhYmVsKS5wYXJzZU9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIGNhbGxlZVBhdGgubm9kZS5uYW1lLFxuICAgICAgICAgICAgICBzZWNvbmRBcmcsXG4gICAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlU2NvcGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN0QXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcsIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgIGluc2VydENvbXBpbGVkVGVtcGxhdGUoYmFiZWwsIHN0YXRlLCB0ZW1wbGF0ZSwgcGF0aCwgdXNlclR5cGVkT3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGUoYmFiZWwsIHN0YXRlLCB0ZW1wbGF0ZSwgcGF0aCwgdXNlclR5cGVkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9IGFzIChiYWJlbDogdHlwZW9mIEJhYmVsKSA9PiBCYWJlbC5QbHVnaW5PYmo8dW5rbm93bj47XG59XG5cbmZ1bmN0aW9uKiBjb25maWd1cmVkTW9kdWxlczxFbnZTcGVjaWZpY09wdGlvbnM+KHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTKSB7XG4gICAgaWYgKFxuICAgICAgbW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUgIT09ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nICYmXG4gICAgICAhc3RhdGUubm9ybWFsaXplZE9wdHMuZW5hYmxlTGVnYWN5TW9kdWxlcy5pbmNsdWRlcyhtb2R1bGVDb25maWcubW9kdWxlTmFtZSlcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBtb2R1bGVDb25maWc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIHBhdGg6IE5vZGVQYXRoPHQuSWRlbnRpZmllcj4sXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+XG4pOiBNb2R1bGVDb25maWcgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBtb2R1bGVDb25maWcgb2YgY29uZmlndXJlZE1vZHVsZXMoc3RhdGUpKSB7XG4gICAgaWYgKHBhdGgucmVmZXJlbmNlc0ltcG9ydChtb2R1bGVDb25maWcubW9kdWxlTmFtZSwgbW9kdWxlQ29uZmlnLmV4cG9ydCkpIHtcbiAgICAgIHJldHVybiBtb2R1bGVDb25maWc7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJ1bnRpbWVFcnJvcklJRkUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgcmVwbGFjZW1lbnRzOiB7IEVSUk9SX01FU1NBR0U6IHN0cmluZyB9KSB7XG4gIGxldCBzdGF0ZW1lbnQgPSBiYWJlbC50ZW1wbGF0ZShgKGZ1bmN0aW9uKCkge1xcbiAgdGhyb3cgbmV3IEVycm9yKCdFUlJPUl9NRVNTQUdFJyk7XFxufSkoKTtgKShcbiAgICByZXBsYWNlbWVudHNcbiAgKSBhcyB0LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHJldHVybiBzdGF0ZW1lbnQuZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNjb3BlTG9jYWxzIHtcbiAgaWYgKHVzZXJUeXBlZE9wdGlvbnMuc2NvcGUpIHtcbiAgICByZXR1cm4gdXNlclR5cGVkT3B0aW9ucy5zY29wZSBhcyBTY29wZUxvY2FscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlTG9jYWxzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQcmVjb21waWxlT3B0aW9uczxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgc2NvcGU6IFNjb3BlTG9jYWxzXG4pOiBQcmVwcm9jZXNzT3B0aW9ucyAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgbGV0IGpzdXRpbHMgPSBuZXcgSlNVdGlscyhiYWJlbCwgc3RhdGUsIHRhcmdldCwgc2NvcGUsIHN0YXRlLnV0aWwpO1xuICBsZXQgbWV0YSA9IE9iamVjdC5hc3NpZ24oeyBqc3V0aWxzIH0sIHVzZXJUeXBlZE9wdGlvbnM/Lm1ldGEpO1xuXG4gIGxldCBvdXRwdXQ6IFByZXByb2Nlc3NPcHRpb25zICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgY29udGVudHM6IHRlbXBsYXRlLFxuICAgIG1ldGEsXG5cbiAgICAvLyBUT0RPOiBlbWJyb2lkZXIncyB0ZW1wbGF0ZS1jb21waWxlciBhbGxvd3MgdGhpcyB0byBiZSBvdmVycmlkZW4gdG8gZ2V0XG4gICAgLy8gYmFja3dhcmQtY29tcGF0aWJsZSBtb2R1bGUgbmFtZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgcmVhbCBuYW1lIG9mIHRoZVxuICAgIC8vIG9uLWRpc2sgZmlsZS4gV2hhdCdzIG91ciBwbGFuIGZvciBtaWdyYXRpbmcgcGVvcGxlIGF3YXkgZnJvbSB0aGF0P1xuICAgIG1vZHVsZU5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgLy8gVGhpcyBpcyBoZXJlIHNvIGl0J3MgKmFsd2F5cyogdGhlIHJlYWwgZmlsZW5hbWUuIEhpc3RvcmljYWxseSwgdGhlcmUgaXNcbiAgICAvLyBhbHNvIGBtb2R1bGVOYW1lYCBidXQgdGhhdCBkaWQgbm90IG1hdGNoIHRoZSByZWFsIG9uLWRpc2sgZmlsZW5hbWUsIGl0XG4gICAgLy8gd2FzIHRoZSBub3Rpb25hbCBydW50aW1lIG1vZHVsZSBuYW1lIGZyb20gY2xhc3NpYyBlbWJlciBidWlsZHMuXG4gICAgZmlsZW5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgYXN0OiBzdGF0ZS5ub3JtYWxpemVkT3B0cy50cmFuc2Zvcm1zLFxuICAgIH0sXG4gIH07XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVzZXJUeXBlZE9wdGlvbnMpKSB7XG4gICAgaWYgKGtleSAhPT0gJ3Njb3BlJykge1xuICAgICAgLy8gYHNjb3BlYCBpbiB0aGUgdXNlci1mYWNpbmcgQVBJIGJlY29tZXMgYGxvY2Fsc2AgaW4gdGhlIGxvdy1sZXZlbFxuICAgICAgLy8gZW1iZXItdGVtcGxhdGUtY29tcGlsZXIgQVBJXG4gICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIG91dHB1dC5sb2NhbHMgPSBzY29wZS5sb2NhbHM7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIGlmIHNjb3BlIGhhcyBkaWZmZXJlbnQga2V5cyBhbmQgdmFsdWVzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVtYXAgdGhlIGtleXMgdG8gdGhlIHZhbHVlc1xuLy8geW91IGNhbiBzZWUgYW4gZXhhbXBsZSBvZiB0aGlzIGluIHRoZSB0ZXN0IFwiY29ycmVjdGx5IGhhbmRsZXMgc2NvcGUgaWYgaXQgY29udGFpbnMga2V5cyBhbmQgdmFsdWVzXCJcbmZ1bmN0aW9uIHJlbWFwSWRlbnRpZmllcnMoYXN0OiBCYWJlbC50eXBlcy5GaWxlLCBiYWJlbDogdHlwZW9mIEJhYmVsLCBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgaWYgKCFzY29wZUxvY2Fscy5uZWVkc1JlbWFwcGluZygpKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBhbGwga2V5cyBhcmUgdGhlIHNhbWUgYXMgdGhlaXIgdmFsdWVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhdmVyc2UoYXN0LCB7XG4gICAgSWRlbnRpZmllcihwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+KSB7XG4gICAgICBpZiAoc2NvcGVMb2NhbHMuaGFzKHBhdGgubm9kZS5uYW1lKSAmJiBwYXRoLm5vZGUubmFtZSAhPT0gc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkge1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBwYXRoIG9ubHkgaWYgdGhlIGtleSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgdmFsdWVcbiAgICAgICAgcGF0aC5yZXBsYWNlV2l0aChiYWJlbC50eXBlcy5pZGVudGlmaWVyKHNjb3BlTG9jYWxzLmdldChwYXRoLm5vZGUubmFtZSkpKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgdGVtcGxhdGU6IHN0cmluZyxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzY29wZUxvY2FscyA9IGJ1aWxkU2NvcGVMb2NhbHModXNlclR5cGVkT3B0aW9ucyk7XG4gIGxldCBvcHRpb25zID0gYnVpbGRQcmVjb21waWxlT3B0aW9ucyhcbiAgICBiYWJlbCxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUsXG4gICAgdGVtcGxhdGUsXG4gICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuXG4gIGxldCBwcmVjb21waWxlUmVzdWx0U3RyaW5nOiBzdHJpbmc7XG5cbiAgaWYgKG9wdGlvbnMuaW5zZXJ0UnVudGltZUVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICBwcmVjb21waWxlUmVzdWx0U3RyaW5nID0gc3RhdGUubm9ybWFsaXplZE9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRhcmdldC5yZXBsYWNlV2l0aChydW50aW1lRXJyb3JJSUZFKGJhYmVsLCB7IEVSUk9SX01FU1NBR0U6IChlcnJvciBhcyBhbnkpLm1lc3NhZ2UgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmVjb21waWxlUmVzdWx0U3RyaW5nID0gc3RhdGUubm9ybWFsaXplZE9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBsZXQgcHJlY29tcGlsZVJlc3VsdEFTVCA9IGJhYmVsLnBhcnNlKGB2YXIgcHJlY29tcGlsZVJlc3VsdCA9ICR7cHJlY29tcGlsZVJlc3VsdFN0cmluZ307IGAsIHtcbiAgICBiYWJlbHJjOiBmYWxzZSxcbiAgICBjb25maWdGaWxlOiBmYWxzZSxcbiAgfSkgYXMgdC5GaWxlO1xuXG4gIHJlbWFwSWRlbnRpZmllcnMocHJlY29tcGlsZVJlc3VsdEFTVCwgYmFiZWwsIHNjb3BlTG9jYWxzKTtcblxuICBsZXQgdGVtcGxhdGVFeHByZXNzaW9uID0gKHByZWNvbXBpbGVSZXN1bHRBU1QucHJvZ3JhbS5ib2R5WzBdIGFzIHQuVmFyaWFibGVEZWNsYXJhdGlvbilcbiAgICAuZGVjbGFyYXRpb25zWzBdLmluaXQgYXMgdC5FeHByZXNzaW9uO1xuXG4gIHQuYWRkQ29tbWVudChcbiAgICB0ZW1wbGF0ZUV4cHJlc3Npb24sXG4gICAgJ2xlYWRpbmcnLFxuICAgIGBcXG4gICR7dGVtcGxhdGUucmVwbGFjZSgvXFwqXFwvL2csICcqXFxcXC8nKX1cXG5gLFxuICAgIC8qIGxpbmUgY29tbWVudD8gKi8gZmFsc2VcbiAgKTtcblxuICBsZXQgdGVtcGxhdGVGYWN0b3J5SWRlbnRpZmllciA9IHN0YXRlLnV0aWwuaW1wb3J0KFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkubW9kdWxlTmFtZSxcbiAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkuZXhwb3J0TmFtZVxuICApO1xuICB0YXJnZXQucmVwbGFjZVdpdGgodC5jYWxsRXhwcmVzc2lvbih0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyLCBbdGVtcGxhdGVFeHByZXNzaW9uXSkpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+IHwgTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnXG4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNjb3BlTG9jYWxzID0gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zKTtcbiAgbGV0IG9wdGlvbnMgPSBidWlsZFByZWNvbXBpbGVPcHRpb25zKFxuICAgIGJhYmVsLFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZSxcbiAgICB0ZW1wbGF0ZSxcbiAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG4gIGxldCBhc3QgPSBzdGF0ZS5ub3JtYWxpemVkT3B0cy5jb21waWxlci5fcHJlcHJvY2Vzcyh0ZW1wbGF0ZSwgeyAuLi5vcHRpb25zLCBtb2RlOiAnY29kZW1vZCcgfSk7XG4gIGxldCB0cmFuc2Zvcm1lZCA9IHN0YXRlLm5vcm1hbGl6ZWRPcHRzLmNvbXBpbGVyLl9wcmludChhc3QpO1xuICBpZiAodGFyZ2V0LmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICh0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuTm9kZT4pLnJlcGxhY2VXaXRoKHQuc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZCkpO1xuICAgIGlmICghc2NvcGVMb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMuZW5hYmxlU2NvcGUpIHtcbiAgICAgICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCdjYWxsZWUnKSk7XG4gICAgICAgIHRhcmdldC5zZXQoJ2NhbGxlZScsIHByZWNvbXBpbGVUZW1wbGF0ZShzdGF0ZS51dGlsLCB0YXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVNjb3BlKGJhYmVsLCB0YXJnZXQsIHNjb3BlTG9jYWxzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAgIC8vIG5lZWQgdG8gYWRkIHNjb3BlLCBzbyBuZWVkIHRvIHJlcGxhY2UgdGhlIGJhY2t0aWNrcyBmb3JtIHdpdGggYSBjYWxsXG4gICAgICAvLyBleHByZXNzaW9uIHRvIHByZWNvbXBpbGVUZW1wbGF0ZVxuICAgICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCd0YWcnKSk7XG4gICAgICBsZXQgbmV3Q2FsbCA9IHRhcmdldC5yZXBsYWNlV2l0aChcbiAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihwcmVjb21waWxlVGVtcGxhdGUoc3RhdGUudXRpbCwgdGFyZ2V0KSwgW3Quc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZCldKVxuICAgICAgKVswXTtcbiAgICAgIHVwZGF0ZVNjb3BlKGJhYmVsLCBuZXdDYWxsLCBzY29wZUxvY2Fscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0YXJnZXQuZ2V0KCdxdWFzaScpLmdldCgncXVhc2lzLjAnKSBhcyBOb2RlUGF0aDx0LlRlbXBsYXRlRWxlbWVudD4pLnJlcGxhY2VXaXRoKFxuICAgICAgICB0LnRlbXBsYXRlRWxlbWVudCh7IHJhdzogdHJhbnNmb3JtZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlRmFjdG9yeUNvbmZpZyhvcHRzOiBSZXF1aXJlZDxPcHRpb25zPikge1xuICBsZXQgbW9kdWxlTmFtZSA9ICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc7XG4gIGxldCBleHBvcnROYW1lID0gJ2NyZWF0ZVRlbXBsYXRlRmFjdG9yeSc7XG4gIGxldCBvdmVycmlkZXMgPSBvcHRzLm91dHB1dE1vZHVsZU92ZXJyaWRlc1ttb2R1bGVOYW1lXT8uW2V4cG9ydE5hbWVdO1xuICByZXR1cm4gb3ZlcnJpZGVzXG4gICAgPyB7IGV4cG9ydE5hbWU6IG92ZXJyaWRlc1swXSwgbW9kdWxlTmFtZTogb3ZlcnJpZGVzWzFdIH1cbiAgICA6IHsgZXhwb3J0TmFtZSwgbW9kdWxlTmFtZSB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNjb3BlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIGxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgcmV0dXJuIHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgW10sXG4gICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgbG9jYWxzXG4gICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgLm1hcCgoW25hbWUsIGlkZW50aWZpZXJdKSA9PlxuICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKG5hbWUpLCB0LmlkZW50aWZpZXIoaWRlbnRpZmllciksIGZhbHNlLCB0cnVlKVxuICAgICAgICApXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHNjb3BlID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3Njb3BlJztcbiAgICB9KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNjb3BlLnNldCgndmFsdWUnLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3Njb3BlJyksIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucHVzaENvbnRhaW5lcihcbiAgICAgICdhcmd1bWVudHMnLFxuICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFt0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc2NvcGUnKSwgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSldKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVQcnVuZUltcG9ydChcbiAgdXRpbDogSW1wb3J0VXRpbCxcbiAgaWRlbnRpZmllcjogTm9kZVBhdGg8dC5FeHByZXNzaW9uIHwgdC5WOEludHJpbnNpY0lkZW50aWZpZXI+XG4pIHtcbiAgaWYgKCFpZGVudGlmaWVyLmlzSWRlbnRpZmllcigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBiaW5kaW5nID0gaWRlbnRpZmllci5zY29wZS5nZXRCaW5kaW5nKGlkZW50aWZpZXIubm9kZS5uYW1lKTtcbiAgLy8gdGhpcyBjaGVja3MgaWYgdGhlIGlkZW50aWZpZXIgKHRoYXQgd2UncmUgYWJvdXQgdG8gcmVtb3ZlKSBpcyB1c2VkIGluXG4gIC8vIGV4YWN0bHkgb25lIHBsYWNlLlxuICBpZiAoXG4gICAgYmluZGluZz8ucmVmZXJlbmNlUGF0aHMucmVkdWNlKChjb3VudCwgcGF0aCkgPT4gKHBhdGgucmVtb3ZlZCA/IGNvdW50IDogY291bnQgKyAxKSwgMCkgPT09IDFcbiAgKSB7XG4gICAgbGV0IHNwZWNpZmllciA9IGJpbmRpbmcucGF0aDtcbiAgICBpZiAoc3BlY2lmaWVyLmlzSW1wb3J0U3BlY2lmaWVyKCkpIHtcbiAgICAgIGxldCBkZWNsYXJhdGlvbiA9IHNwZWNpZmllci5wYXJlbnRQYXRoIGFzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+O1xuICAgICAgdXRpbC5yZW1vdmVJbXBvcnQoZGVjbGFyYXRpb24ubm9kZS5zb3VyY2UudmFsdWUsIG5hbWUoc3BlY2lmaWVyLm5vZGUuaW1wb3J0ZWQpKTtcbiAgICB9XG4gIH1cbiAgaWRlbnRpZmllci5yZW1vdmVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlY29tcGlsZVRlbXBsYXRlKHV0aWw6IEltcG9ydFV0aWwsIHRhcmdldDogTm9kZVBhdGg8dC5Ob2RlPikge1xuICByZXR1cm4gdXRpbC5pbXBvcnQodGFyZ2V0LCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJywgJ3ByZWNvbXBpbGVUZW1wbGF0ZScpO1xufVxuXG5mdW5jdGlvbiBuYW1lKG5vZGU6IHQuU3RyaW5nTGl0ZXJhbCB8IHQuSWRlbnRpZmllcikge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VQbHVnaW48T3B0aW9ucz4oKG9wdGlvbnMpID0+IG9wdGlvbnMpO1xuIl19