"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionParser = void 0;
const scope_locals_1 = require("./scope-locals");
class ExpressionParser {
    constructor(babel) {
        this.babel = babel;
    }
    parseExpression(invokedName, path) {
        switch (path.node.type) {
            case 'ObjectExpression':
                return this.parseObjectExpression(invokedName, path);
            case 'ArrayExpression': {
                return this.parseArrayExpression(invokedName, path);
            }
            case 'StringLiteral':
            case 'BooleanLiteral':
            case 'NumericLiteral':
                return path.node.value;
            default:
                throw path.buildCodeFrameError(`${invokedName} can only accept static options but you passed ${JSON.stringify(path.node)}`);
        }
    }
    parseArrayExpression(invokedName, path) {
        return path.get('elements').map((element) => {
            if (element.isSpreadElement()) {
                throw element.buildCodeFrameError(`spread element is not allowed here`);
            }
            else if (element.isExpression()) {
                return this.parseExpression(invokedName, element);
            }
        });
    }
    parseScope(invokedName, path) {
        let body = undefined;
        if (path.node.type === 'ObjectMethod') {
            body = path.node.body;
        }
        else {
            let { value } = path.node;
            if (this.t.isObjectExpression(value)) {
                throw path.buildCodeFrameError(`Passing an object as the \`scope\` property to inline templates is no longer supported. Please pass a function that returns an object expression instead.`);
            }
            if (this.t.isFunctionExpression(value) || this.t.isArrowFunctionExpression(value)) {
                body = value.body;
            }
        }
        let objExpression = undefined;
        if ((body === null || body === void 0 ? void 0 : body.type) === 'ObjectExpression') {
            objExpression = body;
        }
        else if ((body === null || body === void 0 ? void 0 : body.type) === 'BlockStatement') {
            // SAFETY: We know that the body is a ReturnStatement because we're checking inside
            let returnStatements = body.body.filter((statement) => statement.type === 'ReturnStatement');
            if (returnStatements.length !== 1) {
                throw new Error('Scope functions must have a single return statement which returns an object expression containing references to in-scope values');
            }
            objExpression = returnStatements[0].argument;
        }
        if ((objExpression === null || objExpression === void 0 ? void 0 : objExpression.type) !== 'ObjectExpression') {
            throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` must be an object expression containing only references to in-scope values, or a function that returns an object expression containing only references to in-scope values`);
        }
        return objExpression.properties.reduce((res, prop) => {
            if (this.t.isSpreadElement(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain spread elements`);
            }
            if (this.t.isObjectMethod(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain methods`);
            }
            let { key, value } = prop;
            if (!this.t.isStringLiteral(key) && !this.t.isIdentifier(key)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain static property names`);
            }
            let propName = name(key);
            if (value.type !== 'Identifier') {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain direct references to in-scope values, e.g. { ${propName} } or { ${propName}: ${propName} }`);
            }
            res.add(propName, value.name);
            return res;
        }, new scope_locals_1.ScopeLocals());
    }
    parseObjectExpression(invokedName, path, shouldParseScope = false) {
        let result = {};
        path.get('properties').forEach((property) => {
            let { node } = property;
            if (this.t.isSpreadElement(node)) {
                throw property.buildCodeFrameError(`${invokedName} does not allow spread element`);
            }
            if (node.computed) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let { key } = node;
            if (!this.t.isIdentifier(key) && !this.t.isStringLiteral(key)) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let propertyName = name(key);
            if (shouldParseScope && propertyName === 'scope') {
                result.scope = this.parseScope(invokedName, property);
            }
            else {
                if (this.t.isObjectMethod(node)) {
                    throw property.buildCodeFrameError(`${invokedName} does not accept a method for ${propertyName}`);
                }
                let valuePath = property.get('value');
                if (!valuePath.isExpression()) {
                    throw valuePath.buildCodeFrameError(`must be an expression`);
                }
                result[propertyName] = this.parseExpression(invokedName, valuePath);
            }
        });
        return result;
    }
    get t() {
        return this.babel.types;
    }
}
exports.ExpressionParser = ExpressionParser;
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHByZXNzaW9uLXBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxpREFBNkM7QUFFN0MsTUFBYSxnQkFBZ0I7SUFDM0IsWUFBb0IsS0FBbUI7UUFBbkIsVUFBSyxHQUFMLEtBQUssQ0FBYztJQUFHLENBQUM7SUFFM0MsZUFBZSxDQUFDLFdBQW1CLEVBQUUsSUFBNEI7UUFDL0QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN0QixLQUFLLGtCQUFrQjtnQkFDckIsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxFQUFFLElBQW9DLENBQUMsQ0FBQztZQUN2RixLQUFLLGlCQUFpQixDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxJQUFtQyxDQUFDLENBQUM7YUFDcEY7WUFDRCxLQUFLLGVBQWUsQ0FBQztZQUNyQixLQUFLLGdCQUFnQixDQUFDO1lBQ3RCLEtBQUssZ0JBQWdCO2dCQUNuQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3pCO2dCQUNFLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUM1QixHQUFHLFdBQVcsa0RBQWtELElBQUksQ0FBQyxTQUFTLENBQzVFLElBQUksQ0FBQyxJQUFJLENBQ1YsRUFBRSxDQUNKLENBQUM7U0FDTDtJQUNILENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxXQUFtQixFQUFFLElBQWlDO1FBQ3pFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMxQyxJQUFJLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRTtnQkFDN0IsTUFBTSxPQUFPLENBQUMsbUJBQW1CLENBQUMsb0NBQW9DLENBQUMsQ0FBQzthQUN6RTtpQkFBTSxJQUFJLE9BQU8s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ZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWJlbDogdHlwZW9mIEJhYmVsKSB7fVxuXG4gIHBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZTogc3RyaW5nLCBwYXRoOiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+KTogdW5rbm93biB7XG4gICAgc3dpdGNoIChwYXRoLm5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0RXhwcmVzc2lvbihpbnZva2VkTmFtZSwgcGF0aCBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+KTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUV4cHJlc3Npb24oaW52b2tlZE5hbWUsIHBhdGggYXMgTm9kZVBhdGg8dC5BcnJheUV4cHJlc3Npb24+KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtZXJpY0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gcGF0aC5ub2RlLnZhbHVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGAke2ludm9rZWROYW1lfSBjYW4gb25seSBhY2NlcHQgc3RhdGljIG9wdGlvbnMgYnV0IHlvdSBwYXNzZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHBhdGgubm9kZVxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQXJyYXlFeHByZXNzaW9uKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuQXJyYXlFeHByZXNzaW9uPikge1xuICAgIHJldHVybiBwYXRoLmdldCgnZWxlbWVudHMnKS5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmlzU3ByZWFkRWxlbWVudCgpKSB7XG4gICAgICAgIHRocm93IGVsZW1lbnQuYnVpbGRDb2RlRnJhbWVFcnJvcihgc3ByZWFkIGVsZW1lbnQgaXMgbm90IGFsbG93ZWQgaGVyZWApO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVNjb3BlKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHkgfCB0Lk9iamVjdE1ldGhvZD4pOiBTY29wZUxvY2FscyB7XG4gICAgbGV0IGJvZHk6IHQuQmxvY2tTdGF0ZW1lbnQgfCB0LkV4cHJlc3Npb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocGF0aC5ub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHZhbHVlIH0gPSBwYXRoLm5vZGU7XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGBQYXNzaW5nIGFuIG9iamVjdCBhcyB0aGUgXFxgc2NvcGVcXGAgcHJvcGVydHkgdG8gaW5saW5lIHRlbXBsYXRlcyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnQuaXNGdW5jdGlvbkV4cHJlc3Npb24odmFsdWUpIHx8IHRoaXMudC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICBib2R5ID0gdmFsdWUuYm9keTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb2JqRXhwcmVzc2lvbjogdC5FeHByZXNzaW9uIHwgdW5kZWZpbmVkIHwgbnVsbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChib2R5Py50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgIG9iakV4cHJlc3Npb24gPSBib2R5O1xuICAgIH0gZWxzZSBpZiAoYm9keT8udHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgLy8gU0FGRVRZOiBXZSBrbm93IHRoYXQgdGhlIGJvZHkgaXMgYSBSZXR1cm5TdGF0ZW1lbnQgYmVjYXVzZSB3ZSdyZSBjaGVja2luZyBpbnNpZGVcbiAgICAgIGxldCByZXR1cm5TdGF0ZW1lbnRzID0gYm9keS5ib2R5LmZpbHRlcihcbiAgICAgICAgKHN0YXRlbWVudCkgPT4gc3RhdGVtZW50LnR5cGUgPT09ICdSZXR1cm5TdGF0ZW1lbnQnXG4gICAgICApIGFzIEJhYmVsLnR5cGVzLlJldHVyblN0YXRlbWVudFtdO1xuXG4gICAgICBpZiAocmV0dXJuU3RhdGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTY29wZSBmdW5jdGlvbnMgbXVzdCBoYXZlIGEgc2luZ2xlIHJldHVybiBzdGF0ZW1lbnQgd2hpY2ggcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBjb250YWluaW5nIHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvYmpFeHByZXNzaW9uID0gcmV0dXJuU3RhdGVtZW50c1swXS5hcmd1bWVudDtcbiAgICB9XG5cbiAgICBpZiAob2JqRXhwcmVzc2lvbj8udHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgIGBTY29wZSBvYmplY3RzIGZvciBcXGAke2ludm9rZWROYW1lfVxcYCBtdXN0IGJlIGFuIG9iamVjdCBleHByZXNzaW9uIGNvbnRhaW5pbmcgb25seSByZWZlcmVuY2VzIHRvIGluLXNjb3BlIHZhbHVlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IGV4cHJlc3Npb24gY29udGFpbmluZyBvbmx5IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLnJlZHVjZSgocmVzLCBwcm9wKSA9PiB7XG4gICAgICBpZiAodGhpcy50LmlzU3ByZWFkRWxlbWVudChwcm9wKSkge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBub3QgY29udGFpbiBzcHJlYWQgZWxlbWVudHNgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0TWV0aG9kKHByb3ApKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG5vdCBjb250YWluIG1ldGhvZHNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHByb3A7XG4gICAgICBpZiAoIXRoaXMudC5pc1N0cmluZ0xpdGVyYWwoa2V5KSAmJiAhdGhpcy50LmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG9ubHkgY29udGFpbiBzdGF0aWMgcHJvcGVydHkgbmFtZXNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcm9wTmFtZSA9IG5hbWUoa2V5KTtcblxuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBvbmx5IGNvbnRhaW4gZGlyZWN0IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzLCBlLmcuIHsgJHtwcm9wTmFtZX0gfSBvciB7ICR7cHJvcE5hbWV9OiAke3Byb3BOYW1lfSB9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXMuYWRkKHByb3BOYW1lLCB2YWx1ZS5uYW1lKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbmV3IFNjb3BlTG9jYWxzKCkpO1xuICB9XG5cbiAgcGFyc2VPYmplY3RFeHByZXNzaW9uKFxuICAgIGludm9rZWROYW1lOiBzdHJpbmcsXG4gICAgcGF0aDogTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPixcbiAgICBzaG91bGRQYXJzZVNjb3BlID0gZmFsc2VcbiAgKSB7XG4gICAgbGV0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcblxuICAgIHBhdGguZ2V0KCdwcm9wZXJ0aWVzJykuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgIGxldCB7IG5vZGUgfSA9IHByb3BlcnR5O1xuICAgICAgaWYgKHRoaXMudC5pc1NwcmVhZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgcHJvcGVydHkuYnVpbGRDb2RlRnJhbWVFcnJvcihgJHtpbnZva2VkTmFtZX0gZG9lcyBub3QgYWxsb3cgc3ByZWFkIGVsZW1lbnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgdGhyb3cgcHJvcGVydHkuYnVpbGRDb2RlRnJhbWVFcnJvcihgJHtpbnZva2VkTmFtZX0gY2FuIG9ubHkgYWNjZXB0IHN0YXRpYyBwcm9wZXJ0eSBuYW1lc2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgeyBrZXkgfSA9IG5vZGU7XG4gICAgICBpZiAoIXRoaXMudC5pc0lkZW50aWZpZXIoa2V5KSAmJiAhdGhpcy50LmlzU3RyaW5nTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgIHRocm93IHByb3BlcnR5LmJ1aWxkQ29kZUZyYW1lRXJyb3IoYCR7aW52b2tlZE5hbWV9IGNhbiBvbmx5IGFjY2VwdCBzdGF0aWMgcHJvcGVydHkgbmFtZXNgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHByb3BlcnR5TmFtZSA9IG5hbWUoa2V5KTtcblxuICAgICAgaWYgKHNob3VsZFBhcnNlU2NvcGUgJiYgcHJvcGVydHlOYW1lID09PSAnc2NvcGUnKSB7XG4gICAgICAgIHJlc3VsdC5zY29wZSA9IHRoaXMucGFyc2VTY29wZShpbnZva2VkTmFtZSwgcHJvcGVydHkgYXMgTm9kZVBhdGg8dHlwZW9mIG5vZGU+KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnQuaXNPYmplY3RNZXRob2Qobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBwcm9wZXJ0eS5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgYCR7aW52b2tlZE5hbWV9IGRvZXMgbm90IGFjY2VwdCBhIG1ldGhvZCBmb3IgJHtwcm9wZXJ0eU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlUGF0aCA9IChwcm9wZXJ0eSBhcyBOb2RlUGF0aDx0eXBlb2Ygbm9kZT4pLmdldCgndmFsdWUnKTtcbiAgICAgICAgaWYgKCF2YWx1ZVBhdGguaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICB0aHJvdyB2YWx1ZVBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihgbXVzdCBiZSBhbiBleHByZXNzaW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZSwgdmFsdWVQYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGdldCB0KCkge1xuICAgIHJldHVybiB0aGlzLmJhYmVsLnR5cGVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5hbWUobm9kZTogdC5TdHJpbmdMaXRlcmFsIHwgdC5JZGVudGlmaWVyKTogc3RyaW5nIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxufVxuIl19